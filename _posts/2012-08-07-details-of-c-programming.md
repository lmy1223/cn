---
layout: post
title: "C语言细节"
description: ""
category: 程序语言
tags: [C语言, 细节]
---

这篇文章主要讨论C语言细节问题。在找一份工作的时候,语言细节占的比例非常小,之前看某个贴着讨论,估计语言细节在面试中,占了10%的比重都不到,那为什么还要研究C语言的细节呢,我觉得有三个原因促使我总结这篇文章：

- 总会有些面试官喜欢问这样的问题,尤其是偏底层开发的面试官.
- 总有有那么两个2B同学、同事,搞两个很偏的知识点来考你,把你难倒以后,他就乐呵呵的满足了.
- 对C语言有更加巩固的基础,增加信心,在代码出错时,可以非常肯定哪里没有错,而把精力花在真正的问题上.


###1. switch注意事项( case后面只能是整型或字符型的常量或表达式）

1. case后面可以用continue,与break的功能一模一样

2. case后面可以是常量,常量表达式,#define宏,枚举值。但是不能是const常量,这是因为C语言中const不是真正的常量,只不过是只读的变量,如果下面的代码位于cpp文件中,也就是采用C++的编译器,则case zero: puts("0");是没有问题的。这也反面证明了,C语言中没有真正的常量,const代表只读。

3. 最好不要缺省default语句,且用default处理异常情况。


    #include <stdio.h>  
    #include <stdlib.h>  
    #define FIVE 5  
    enum em{SIX=6};  
    int main()  
    {  
     int a = 1;  
     int i = 0;  
     const int zero = 0;  
     for( i = 0; i < 7; i++ )  
     {  
             switch( i )  
             {  
             //case zero:puts("0");break;
     //gcc 报错"错误： case 标号不能还原为一个整常量"
             case 1:puts("1");break;  
             case 2:puts("2");continue;  
             case 3:puts("3");continue;  
             case 2 + 2:puts("4");break;  
             case FIVE: puts("5");break;  
             case SIX: puts("6");break;  
             default: puts("error");  
             }  
     }  
        return 0;  
    }  



###2.无符号型与有符号型数据相加 

	#include <stdio.h>
	int main(int argc, char* argv[])
	{
		unsigned int a = -20;
		int b = 10;
		if( a + b > 6 )
		{
			puts(">6");
		}
		else
		{
			puts("<6");
		}
		return 0;
	}

	
以上代码输出结果是 >6,原因是编译器做了隐私转换,把int 转换为unsigned int,编译器就会把b转换成一个很大的正数。


###3.static的作用

static在c语言中有两个作用。(1)限制变量存储域(用static修饰的变量都存储在静态存储区,在整个程序的生命周期内可见),(2)限制函数作用域(static修饰的函数,只在同一源文件中可见,同一工程的其他源文件也不可见)。C++对static进行了扩展,用定义静态数据成员和成员函数,静态数据成员和静态成员函数都是类共享,而不是某个对象特有。还要注意的就是,静态变量自动初始化为0


###4.内存的三种分配方式

1. 从静态存储区域分配。内存在程序编译的时候就已经分配好,这块内存在程序的整个运行期间都存在。例如全局变量,static变量。
2. 在栈上创建。在执行函数时,函数内局部变量的存储单元都可以在栈上创建,函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中,效率很高,但是分配的内存容量有限。
3. 从堆上分配,亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存,程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定,使用非常灵活,但问题也最多。

发生内存错误是件非常麻烦的事情。编译器不能自动发现这些错误,通常是在程序运行时才能捕捉到。而这些错误大多没有明显的症状,时隐时现,增加了改错的难度。有时用户怒气冲冲地把你找来,程序却没有发生任何问题,你一走,错误又发作了。

**常见的内存错误及其对策如下：**

1. 内存分配未成功,却使用了它。编程新手常犯这种错误,因为他们没有意识到内存分配会不成功。常用解决办法是,在使用内存之前检查指针是否为NULL。如果指针p是函数的参数,那么在函数的入口处用assert(p!=NULL)进行检查。如果是用malloc或new来申请内存,应该用if(p==NULL)或if(p!=NULL)进行防错处理。
2. 内存分配虽然成功,但是尚未初始化就引用它。犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零,导致引用初值错误（例如数组）。内存的缺省初值究竟是什么并没有统一的标准,尽管有些时候为零值,我们宁可信其无不可信其有。所以无论用何种方式创建数组,都别忘了赋初值,即便是赋零值也不可省略,不要嫌麻烦。
3. 内存分配成功并且已经初始化,但操作越过了内存的边界。
例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中,循环次数很容易搞错,导致数组操作越界。
4. 忘记了释放内存,造成内存泄露。
含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足,你看不到错误。终有一次程序突然死掉,系统出现提示：内存耗尽。动态内存的申请与释放必须配对,程序中malloc与free的使用次数一定要相同,否则肯定有错误（new/delete同理）。
5. 释放了内存却继续使用它。

有三种情况：

1. 程序中的对象调用关系过于复杂,实在难以搞清楚某个对象究竟是否已经释放了内存,此时应该重新设计数据结构,从根本上解决对象管理的混乱局面。
2. 函数的return语句写错了,注意不要返回指向“栈内存”的“指针”或者“引用”,因为该内存在函数体结束时被自动销毁。
3. 使用free或delete释放了内存后,没有将指针设置为NULL。导致产生“野指针”。


####指针使用规则：

【规则7-2-1】用malloc或new申请内存之后,应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。

【规则7-2-2】不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。

【规则7-2-3】避免数组或指针的下标越界,特别要当心发生“多1”或者“少1”操作。

【则7-2-4】动态内存的申请与释放必须配对,防止内存泄漏。

【规则7-2-5】用free或delete释放了内存之后,立即将指针设置为NULL,防止产生“野指针”。


###5.空结构体的大小

	#include <stdio.h>
	struct stu
	{
	};
	int main(int argc, char* argv[])
	{
	        printf("%d\n", sizeof(struct stu));
	        return 0;
	}


用g++编译输出结果为1,用vc++6.0编译输出结果为1,只有用gcc编译输出结果为0特殊情况,经常考的题目是定义一个空的类,然后sizeof这个类,输出结果为1,问：为什么是1不是0？

**答：**编译器不能产生一个没有任何容积的数据类型,编译器认为任何一种数据类型都有其大小,用他来定义一个变量能够分配确定大小的空间,所以,编译器认为任何数据类型都有其大小。并且,编译器构造一个结构体数据类型是用来打包一些数据的,而最小的数据成员(char)需要一字节,编译器为每个结构体类型至少预留一个字节的空间,所以空结构体/空类的大小为一字节。


###6.柔性数组

	#include <stdio.h>
	#include <stdlib.h>
	struct student
	{
			int id;
			char sex;
			int a[];
	};
	
	int main()
	{
	
			int i = 0;
			struct	student a;
			struct student *p = &a;
			struct student *q = ( struct student * )
			malloc( sizeof( struct student) + 10 * sizeof( int ) );
	
			printf("sizeof( a ) = %d\n ", sizeof( a ) ); //8
			printf("sizeof( *p ) = %d\n ", sizeof( *p ) ); //8
			printf("sizeof( *q ) = %d \n", sizeof( *q ) ); //8
	
			for(  i = 0; i < 10; i ++ )
			{
				(*q).a[i] = i * i;
			}
			for(  i = 0; i < 10; i ++ )
			{
				printf("%d\t", 	(*q).a[i]);
				// 0, 1, 4,......,81
			}
			puts("");
			return 0;
	}


 这里定义了一个可变长的结构体,由sizeof( a )可知,数组a并没有占任何存储空间,为了给成员数组分配内存,必须使用malloc,但是分配完以后,sizeof( \*q)还是8。可以理解,需要时柔性数组是结构体的一员,仅此而已。也可以认为柔性数组跟结构体没有任何关系,只是“挂羊头,卖狗肉”罢了,算不得结构体的正式成员。
      柔性数组与成员指针完全不是一回事。

	struct student
	{
			int id;
			int *a;
	};


上面结构体里定义了一个指针,指针要占内存,且指向一块内存,柔性数组的功能和成员指针类似,但却是完全不同的东西,柔性数组中,数组的成员和结构体其他成员地址是连续的,成员指针就完全不一样了。 很少见人用柔性数组。


###7.枚举和\#define的区别

1. 枚举常量是实体中的一种,但宏不是实体；
2. 枚举常量属于常量,但宏不是常量（有些书把类对象宏称为预处理常量,这是错误的说法,标准C/C++没有预处理常量这种不知从哪里冒出来的说法）；
3. 枚举常量具有类型,但宏没有类型


###8.类型定义、别名

可以用typedef 和define来为已有的数据类型定义新的数据类型,准确地说,应该是取一个别名。

(1)typedef 不支持类型扩展

	#define INT32 int
	unsigned INT32 i = 10;
	typefdef int int32;
	unsigned int32 j = 10; //出错


(2)\#define有副作用

	#define PCHAR char\*
	PCHAR p1, p2; // p2是char型,而不是期望的char\*型数据
	typedef pchar char\*;
	pchar p3, p4; 


###9.有关注释

A. int/\*……\*/i; 合法,编译器将剔除注释,然后用空格代替原来的注释

B.char \*s = "abcdefgh;      //higklmn"; 合法,用双引号括起来的都是常量

C.//Is it a \ 合法,\是续接符
valid comment

D. in/\*……\*/t i; 不合法,见A解释。


###10.如何将数值存储到指定内存

假设我们现在需要往内出地址,0x12ff7c 上存放一个整型数0x100,那么怎样才能做到呢？这题看着很变态,但是确实有用的着的地方。曾经我找工作的时候就遇到过这个问题,当然了,是关于嵌入式方面的工作。

1. int \*p = (int \*)0x12ff7c;
 \*p = 0x100;

2. \*(int \*)0x1277fc = 0x100;

这题很特别,写出来一看就懂,第一次遇到这种题的人大多都蒙了。


###11.如何不使用任何变量编写strlen函数？

代码如下：

	int my_strlen1( const char \*strDest)
	{
	return \*strDest ? 1 + my_strlen1(strDest + 1 ) : 0;
	}


更符合规范的代码示例：

	int my_strlen2( const char \*strDest)
	{
		assert( NULL != strDest );
		return ('\0' != \*strDest ) ? ( 1 + my_strlen2(
		strDest + 1 )) : 0;
	}


###12.下面代码的输出结果是多少？为什么？ 

	#include <stdio.h>
	#include <string.h>
	int main(int argc, char* argv[])
	{
		char a[1000];
		int i;
		for( i = 0; i < 1000; i++)
		{
			a[i] = -1 - i;
		}
		printf("%d\n",
		strlen(a));
		return 0;
	}


答：输出结果是255。只要知道两点,这题也不难（1.char其实可以看成是只占一个字节的整型。 2.char型数据的表示范围是  -128——127),由char数据类型的表示范围可知,a\[0\] ——a\[254\]都不为0, 而a\[255\]的值为0, 也就是字符串中的'\0',所以数据结果为255.


###13.内存对齐

	#include <stdio.h>
	struct st1
	{
		char c1;
		short s;
		char s2;
		int i;
	};
	
	struct st2
	{
		char c1;
		char c2;
		short s;
		int i;
	};
	int main(int argc, char* argv[])
	{
		printf("sizeof(struct st1) = %d \nsizeof(struct st2) = %d\n",
		sizeof(struct st1), sizeof(struct st2));
			return 0;
	}


输出结果是：

	sizeof(struct st1) = 12 
	sizeof(struct st2) = 8

对于大多数的程序员来说,内存对齐基本上是透明的,这是编译器该干的活,编译器为程序中的每个数据单元安排在合适的位置上,从而导致了相同的变量,不同声明顺序的结构体大小的不同。 那么编译器为什么要进行内存对齐呢？程序1中结构体按常理来理解sizeof(st1)和sizeof(st2)结果都应该是8 。经过内存对齐后,结构体的空间反而增大了。 在解释内存对齐的作用前,先来看下内存对齐的规则：

(1) 对于结构的各个成员,第一个成员位于偏移为0的位置,以后每个数据成员的偏移量必须是min(#pragma pack()指定的数,这个数据成员的自身长度) 的倍数。 

(2) 在数据成员完成各自对齐之后,结构(或联合)本身也要进行对齐,对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中,比较小的那个进行。 #pragma pack(n) 表示设置为n字节对齐。 VC6默认8字节对齐 (见参考资料5)
																													   

###14.循环语句注意事项

1. 在多重循环中,如果有可能,应将最长的循环放在最内层,最短的循环放在最外层,以减少cpu跨切的次数
2. 建议for循环的循环控制变量的取值采用“半开半闭区间”写法
3. 不要在for循环中修改循环变量,放置循环失控


	for( n = 0; n < 10; n++ )
	{
	……
	n = 8;
	……
	}
	


4. 循环要尽可能的短,要使代码清晰,一目了然
5. 把循环嵌套控制在3层以内


###15.define的注意事项

1.用define宏定义注释符号是错误的
如：#define BSC //
BSC my single-line comment
上面语句中,由于注释先于预处理指令处理,所以出错。

2. 定义一年有多少秒

	#define SEC_A_YEAR 60\*60\*24\*365

上面定义不可靠,在16位系统下,把这样一个值复制给整型变量会溢出,且一年有多少秒也不可能是负数。
正确的定义：
j
    #define SEC_A_YEAR 60\*60\*24\*365UL

3. 求两个数的和

	#define SUM(x) (x)+(x)

考虑下面这种情况,如果x是表达式5 \* 3,而代码又写成 SUM(x) \* SUM(x),则替换以后变成了(5 \* 3 ) + (5 \* 3 ) \* (5 \* 3 ) + (5 \* 3 ),与期望不符,所以最外层括号最好别省。

4. \#define EMPTY 

上面的宏定义正确吗？这样的定义是可行的,只是EMPTY不代表任何意思。如windows编程时经常碰到的\_\_in \_\_out宏,它们在程序中不表达任何意思,只是用于函数参数,帮助用户理解哪些是输入参数,哪些是输出参数
